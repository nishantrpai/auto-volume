{"version":3,"file":"contentScript.js","mappings":";;;;;AAAA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,eAAe,OAAO,WAAW;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,eAAe,OAAO,WAAW;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,6BAA6B,MAAM,EAAE,OAAO;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,QAAQ;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,eAAe,OAAO,WAAW;AAClG;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,eAAe,OAAO,WAAW;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,6BAA6B,MAAM,EAAE,OAAO;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,sDAAsD,oDAAoD,EAAE,eAAe,qBAAqB,oBAAoB;AACpK;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,uBAAuB,eAAe;AACtC,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA,gBAAgB,+BAA+B;AAC/C;AACA,uBAAuB,eAAe;AACtC;AACA;AACA,iBAAiB;AACjB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,gB","sources":["webpack://auto-volume-adjuster/./src/contentScript.js"],"sourcesContent":["// Auto Volume Adjuster Content Script\n// Automatically adjusts volume of audio/video elements to stay within min/max thresholds\n\nlet settings = {\n    enabled: true,\n    minVolume: 20,\n    maxVolume: 80\n};\n\nlet isProcessing = false;\nlet mediaElements = new Set();\nlet volumeCheckInterval = null;\nlet webAudioContexts = new Set();\nlet gainNodes = new Set();\n\n// Load settings from storage\nasync function loadSettings() {\n    try {\n        const result = await chrome.storage.sync.get({\n            enabled: true,\n            minVolume: 20,\n            maxVolume: 80\n        });\n        settings = result;\n        console.log('Auto Volume: Settings loaded', settings);\n    } catch (error) {\n        console.error('Auto Volume: Error loading settings', error);\n    }\n}\n\n// Convert percentage to decimal volume (0-1)\nconst percentToVolume = (percent) => Math.max(0, Math.min(1, percent / 100));\n\n// Convert decimal volume to percentage\nconst volumeToPercent = (volume) => Math.round(volume * 100);\n\n// Adjust volume of a media element\nconst adjustMediaVolume = (element) => {\n    if (!element || !settings.enabled) return;\n    \n    // Skip if element is muted (user choice)\n    if (element.muted) return;\n    \n    const currentVolume = element.volume;\n    const currentPercent = volumeToPercent(currentVolume);\n    \n    let newPercent = currentPercent;\n    let adjusted = false;\n    let adjustmentType = '';\n    \n    // Check if volume is below minimum\n    if (currentPercent < settings.minVolume) {\n        newPercent = settings.minVolume;\n        adjusted = true;\n        adjustmentType = 'boosted';\n        console.log(`Auto Volume: Boosting volume from ${currentPercent}% to ${newPercent}%`);\n    }\n    // Check if volume is above maximum\n    else if (currentPercent > settings.maxVolume) {\n        newPercent = settings.maxVolume;\n        adjusted = true;\n        adjustmentType = 'reduced';\n        console.log(`Auto Volume: Reducing volume from ${currentPercent}% to ${newPercent}%`);\n    }\n    \n    if (adjusted) {\n        const newVolume = percentToVolume(newPercent);\n        \n        // Prevent feedback loops by temporarily removing event listeners\n        const tempVolumeHandler = () => {};\n        element.removeEventListener('volumechange', tempVolumeHandler);\n        \n        // Set the new volume\n        element.volume = newVolume;\n        \n        // Add a small delay before re-enabling volume change detection\n        setTimeout(() => {\n            // Re-add event listener if needed (this is handled in findMediaElements)\n        }, 100);\n        \n        // Add visual indicator for a moment\n        showVolumeIndicator(element, newPercent, adjustmentType);\n        \n        // If we're boosting to 100% and it might still be too quiet\n        if (newPercent >= 100 && adjustmentType === 'boosted') {\n            setTimeout(() => {\n                showSystemVolumeHint(element);\n            }, 3000); // Show system volume hint 3 seconds after hitting 100%\n        }\n    }\n};\n\n// Show a temporary visual indicator when volume is adjusted\nconst showVolumeIndicator = (element, volume, adjustmentType = '') => {\n    // Remove any existing indicator\n    const existingIndicator = element.parentNode?.querySelector('.auto-volume-indicator');\n    if (existingIndicator) {\n        existingIndicator.remove();\n    }\n    \n    // Create volume indicator with appropriate icon\n    const indicator = document.createElement('div');\n    indicator.className = 'auto-volume-indicator';\n    \n    let icon = 'ðŸ”Š';\n    let color = '#4CAF50';\n    if (adjustmentType === 'boosted') {\n        icon = 'ðŸ”Šâ†—ï¸';\n        color = '#2196F3';\n    } else if (adjustmentType === 'reduced') {\n        icon = 'ðŸ”Šâ†˜ï¸';\n        color = '#FF9800';\n    }\n    \n    indicator.innerHTML = `${icon} ${volume}%`;\n    indicator.style.cssText = `\n        position: absolute;\n        top: 10px;\n        left: 10px;\n        background: rgba(0, 0, 0, 0.9);\n        color: white;\n        padding: 8px 12px;\n        border-radius: 6px;\n        font-size: 13px;\n        font-family: -apple-system, BlinkMacSystemFont, sans-serif;\n        font-weight: 600;\n        z-index: 99999;\n        pointer-events: none;\n        transition: opacity 0.3s ease;\n        border-left: 3px solid ${color};\n        box-shadow: 0 2px 8px rgba(0,0,0,0.3);\n    `;\n    \n    // Position relative to the video element\n    const rect = element.getBoundingClientRect();\n    if (rect.width > 0 && rect.height > 0) {\n        if (element.parentNode) {\n            const parent = element.parentNode;\n            if (parent.style.position === '' || parent.style.position === 'static') {\n                parent.style.position = 'relative';\n            }\n            parent.appendChild(indicator);\n            \n            // Remove indicator after 2.5 seconds\n            setTimeout(() => {\n                if (indicator.parentNode) {\n                    indicator.style.opacity = '0';\n                    setTimeout(() => {\n                        if (indicator.parentNode) {\n                            indicator.remove();\n                        }\n                    }, 300);\n                }\n            }, 2500);\n        }\n    }\n};\n\n// Show a system volume hint when web volume is at maximum\nconst showSystemVolumeHint = (element) => {\n    // Remove any existing hint\n    const existingHint = element.parentNode?.querySelector('.auto-volume-system-hint');\n    if (existingHint) {\n        existingHint.remove();\n    }\n    \n    // Create system volume hint\n    const hint = document.createElement('div');\n    hint.className = 'auto-volume-system-hint';\n    hint.innerHTML = `ðŸ”ŠðŸ’» Web volume at 100%<br><small>Check system volume for louder audio</small>`;\n    hint.style.cssText = `\n        position: absolute;\n        top: 50px;\n        left: 10px;\n        background: rgba(33, 150, 243, 0.95);\n        color: white;\n        padding: 10px 12px;\n        border-radius: 8px;\n        font-size: 12px;\n        font-family: -apple-system, BlinkMacSystemFont, sans-serif;\n        font-weight: 500;\n        z-index: 99999;\n        pointer-events: none;\n        transition: opacity 0.3s ease;\n        border-left: 3px solid #1976D2;\n        box-shadow: 0 3px 12px rgba(0,0,0,0.4);\n        max-width: 200px;\n        text-align: center;\n        line-height: 1.3;\n    `;\n    \n    // Position relative to the video element\n    const rect = element.getBoundingClientRect();\n    if (rect.width > 0 && rect.height > 0) {\n        if (element.parentNode) {\n            const parent = element.parentNode;\n            if (parent.style.position === '' || parent.style.position === 'static') {\n                parent.style.position = 'relative';\n            }\n            parent.appendChild(hint);\n            \n            // Remove hint after 4 seconds\n            setTimeout(() => {\n                if (hint.parentNode) {\n                    hint.style.opacity = '0';\n                    setTimeout(() => {\n                        if (hint.parentNode) {\n                            hint.remove();\n                        }\n                    }, 300);\n                }\n            }, 4000);\n        }\n    }\n};\n\n// Find and monitor all media elements\nconst findMediaElements = () => {\n    const audioElements = document.querySelectorAll('audio');\n    const videoElements = document.querySelectorAll('video');\n    \n    [...audioElements, ...videoElements].forEach(element => {\n        if (!mediaElements.has(element)) {\n            mediaElements.add(element);\n            \n            // Initial volume check\n            adjustMediaVolume(element);\n            \n            // Listen for volume changes and immediately re-adjust\n            element.addEventListener('volumechange', () => {\n                // Small delay to let the volume change complete, then re-adjust\n                setTimeout(() => {\n                    if (settings.enabled) {\n                        adjustMediaVolume(element);\n                    }\n                }, 50);\n            });\n            \n            // Listen for when media starts playing\n            element.addEventListener('play', () => {\n                setTimeout(() => {\n                    if (settings.enabled) {\n                        adjustMediaVolume(element);\n                    }\n                }, 50);\n            });\n            \n            // Listen for when media loads\n            element.addEventListener('loadeddata', () => {\n                setTimeout(() => {\n                    if (settings.enabled) {\n                        adjustMediaVolume(element);\n                    }\n                }, 50);\n            });\n            \n            // Listen for when media metadata loads (volume info available)\n            element.addEventListener('loadedmetadata', () => {\n                setTimeout(() => {\n                    if (settings.enabled) {\n                        adjustMediaVolume(element);\n                    }\n                }, 50);\n            });\n            \n            // Listen for when playback rate changes (some sites change volume with playback)\n            element.addEventListener('ratechange', () => {\n                setTimeout(() => {\n                    if (settings.enabled) {\n                        adjustMediaVolume(element);\n                    }\n                }, 50);\n            });\n            \n            console.log('Auto Volume: Monitoring new media element', element.tagName);\n        }\n    });\n};\n\n// Periodic check for volume adjustments\nconst startVolumeMonitoring = () => {\n    if (volumeCheckInterval) {\n        clearInterval(volumeCheckInterval);\n    }\n    \n    volumeCheckInterval = setInterval(() => {\n        if (settings.enabled) {\n            // Monitor HTML5 media elements\n            mediaElements.forEach(element => {\n                // Remove elements that are no longer in the DOM\n                if (!document.contains(element)) {\n                    mediaElements.delete(element);\n                    return;\n                }\n                \n                // Adjust volume for all media elements, not just playing ones\n                // This ensures we catch volume changes immediately\n                adjustMediaVolume(element);\n            });\n            \n            // Monitor Web Audio gain nodes\n            monitorWebAudioGain();\n            \n            // Also check for any new media elements that might have appeared\n            findMediaElements();\n        }\n    }, 250); // Check every 250ms for more responsive volume control\n};\n\n// Set up mutation observer to detect new media elements\nconst setupMutationObserver = () => {\n    const observer = new MutationObserver((mutations) => {\n        if (isProcessing) return;\n        isProcessing = true;\n        \n        setTimeout(() => {\n            findMediaElements();\n            isProcessing = false;\n        }, 100);\n    });\n    \n    observer.observe(document.body, {\n        childList: true,\n        subtree: true\n    });\n};\n\n// Web Audio API monitoring and control\nconst setupWebAudioMonitoring = () => {\n    // Hook into AudioContext creation\n    const originalAudioContext = window.AudioContext || window.webkitAudioContext;\n    if (originalAudioContext) {\n        const AudioContextProxy = function(...args) {\n            const ctx = new originalAudioContext(...args);\n            webAudioContexts.add(ctx);\n            \n            // Hook into createGain to monitor gain nodes\n            const originalCreateGain = ctx.createGain.bind(ctx);\n            ctx.createGain = function() {\n                const gainNode = originalCreateGain();\n                gainNodes.add(gainNode);\n                \n                // Monitor gain changes\n                const originalGainValue = gainNode.gain.value;\n                Object.defineProperty(gainNode.gain, 'value', {\n                    get() {\n                        return this._value || originalGainValue;\n                    },\n                    set(newValue) {\n                        this._value = newValue;\n                        if (settings.enabled) {\n                            setTimeout(() => adjustWebAudioGain(gainNode), 50);\n                        }\n                    }\n                });\n                \n                return gainNode;\n            };\n            \n            console.log('Auto Volume: Monitoring Web Audio Context');\n            return ctx;\n        };\n        \n        // Replace the global constructors\n        window.AudioContext = AudioContextProxy;\n        if (window.webkitAudioContext) {\n            window.webkitAudioContext = AudioContextProxy;\n        }\n    }\n};\n\n// Adjust Web Audio API gain nodes\nconst adjustWebAudioGain = (gainNode) => {\n    if (!gainNode || !settings.enabled) return;\n    \n    const currentGain = gainNode.gain.value;\n    const currentPercent = Math.round(currentGain * 100);\n    \n    let newPercent = currentPercent;\n    let adjusted = false;\n    let adjustmentType = '';\n    \n    // Check if gain is below minimum\n    if (currentPercent < settings.minVolume) {\n        newPercent = settings.minVolume;\n        adjusted = true;\n        adjustmentType = 'boosted';\n        console.log(`Auto Volume: Boosting Web Audio gain from ${currentPercent}% to ${newPercent}%`);\n    }\n    // Check if gain is above maximum  \n    else if (currentPercent > settings.maxVolume) {\n        newPercent = settings.maxVolume;\n        adjusted = true;\n        adjustmentType = 'reduced';\n        console.log(`Auto Volume: Reducing Web Audio gain from ${currentPercent}% to ${newPercent}%`);\n    }\n    \n    if (adjusted) {\n        const newGain = newPercent / 100;\n        gainNode.gain.setValueAtTime(newGain, gainNode.context.currentTime);\n        \n        // Show visual indicator if we can find a related media element\n        const mediaElement = findRelatedMediaElement();\n        if (mediaElement) {\n            showVolumeIndicator(mediaElement, newPercent, adjustmentType);\n        } else {\n            showFloatingVolumeIndicator(newPercent, adjustmentType);\n        }\n    }\n};\n\n// Find a media element that might be related to Web Audio\nconst findRelatedMediaElement = () => {\n    // Look for any video or audio element that might be playing\n    const allMedia = document.querySelectorAll('video, audio');\n    for (const element of allMedia) {\n        if (!element.paused && !element.muted) {\n            return element;\n        }\n    }\n    \n    // If no playing media, return the first video element we find\n    const firstVideo = document.querySelector('video');\n    if (firstVideo) return firstVideo;\n    \n    // Look for common player containers\n    const playerContainers = document.querySelectorAll(\n        '.player, .video-player, .audio-player, [class*=\"player\"], [id*=\"player\"]'\n    );\n    if (playerContainers.length > 0) {\n        return playerContainers[0];\n    }\n    \n    return null;\n};\n\n// Show floating volume indicator when no media element is available\nconst showFloatingVolumeIndicator = (volume, adjustmentType = '') => {\n    // Remove any existing floating indicator\n    const existingIndicator = document.querySelector('.auto-volume-floating-indicator');\n    if (existingIndicator) {\n        existingIndicator.remove();\n    }\n    \n    // Create floating volume indicator\n    const indicator = document.createElement('div');\n    indicator.className = 'auto-volume-floating-indicator';\n    \n    let icon = 'ðŸ”Š';\n    let color = '#4CAF50';\n    if (adjustmentType === 'boosted') {\n        icon = 'ðŸ”Šâ†—ï¸';\n        color = '#2196F3';\n    } else if (adjustmentType === 'reduced') {\n        icon = 'ðŸ”Šâ†˜ï¸';\n        color = '#FF9800';\n    }\n    \n    indicator.innerHTML = `${icon} ${volume}%`;\n    indicator.style.cssText = `\n        position: fixed;\n        top: 20px;\n        right: 20px;\n        background: rgba(0, 0, 0, 0.9);\n        color: white;\n        padding: 12px 16px;\n        border-radius: 8px;\n        font-size: 14px;\n        font-family: -apple-system, BlinkMacSystemFont, sans-serif;\n        font-weight: 600;\n        z-index: 999999;\n        pointer-events: none;\n        transition: opacity 0.3s ease;\n        border-left: 4px solid ${color};\n        box-shadow: 0 4px 12px rgba(0,0,0,0.3);\n    `;\n    \n    document.body.appendChild(indicator);\n    \n    // Remove indicator after 2.5 seconds\n    setTimeout(() => {\n        if (indicator.parentNode) {\n            indicator.style.opacity = '0';\n            setTimeout(() => {\n                if (indicator.parentNode) {\n                    indicator.remove();\n                }\n            }, 300);\n        }\n    }, 2500);\n};\n\n// Monitor all Web Audio gain nodes periodically\nconst monitorWebAudioGain = () => {\n    gainNodes.forEach(gainNode => {\n        try {\n            if (gainNode.context && gainNode.context.state !== 'closed') {\n                adjustWebAudioGain(gainNode);\n            } else {\n                // Remove closed/invalid gain nodes\n                gainNodes.delete(gainNode);\n            }\n        } catch (error) {\n            // Remove invalid gain nodes\n            gainNodes.delete(gainNode);\n        }\n    });\n};\n\n// Get current volume of playing media (including Web Audio)\nconst getCurrentVolume = () => {\n    let maxVolume = 0;\n    let hasMedia = false;\n    let isAtMaxVolume = false;\n    let totalElements = 0;\n    \n    // Check HTML5 media elements\n    mediaElements.forEach(element => {\n        if (document.contains(element)) {\n            totalElements++;\n            if (!element.paused && !element.muted) {\n                hasMedia = true;\n                maxVolume = Math.max(maxVolume, element.volume);\n                if (element.volume >= 0.99) { // Consider 99%+ as max volume\n                    isAtMaxVolume = true;\n                }\n            }\n        }\n    });\n    \n    // Check Web Audio gain nodes\n    gainNodes.forEach(gainNode => {\n        try {\n            if (gainNode.context && gainNode.context.state !== 'closed') {\n                hasMedia = true;\n                totalElements++;\n                const gainValue = gainNode.gain.value;\n                maxVolume = Math.max(maxVolume, gainValue);\n                if (gainValue >= 0.99) {\n                    isAtMaxVolume = true;\n                }\n            }\n        } catch (error) {\n            // Ignore invalid gain nodes\n        }\n    });\n    \n    // If no playing media, check all media elements\n    if (!hasMedia && totalElements > 0) {\n        mediaElements.forEach(element => {\n            if (document.contains(element)) {\n                hasMedia = true;\n                maxVolume = Math.max(maxVolume, element.volume);\n                if (element.volume >= 0.99) {\n                    isAtMaxVolume = true;\n                }\n            }\n        });\n    }\n    \n    return { \n        volume: maxVolume, \n        hasMedia, \n        isAtMaxVolume,\n        totalElements \n    };\n};\n\n// Adjust all media elements to a target volume (called by background script)\nconst adjustAllMediaToTarget = (targetVolumePercent, adjustmentType) => {\n    if (!settings.enabled) return;\n    \n    const targetVolume = percentToVolume(targetVolumePercent);\n    let adjustedCount = 0;\n    \n    // Adjust HTML5 media elements\n    mediaElements.forEach(element => {\n        if (document.contains(element) && !element.muted) {\n            const oldVolume = element.volume;\n            element.volume = targetVolume;\n            \n            if (Math.abs(oldVolume - targetVolume) > 0.01) {\n                adjustedCount++;\n                showVolumeIndicator(element, targetVolumePercent, adjustmentType);\n            }\n        }\n    });\n    \n    // Adjust Web Audio gain nodes\n    gainNodes.forEach(gainNode => {\n        try {\n            if (gainNode.context && gainNode.context.state !== 'closed') {\n                const oldGain = gainNode.gain.value;\n                gainNode.gain.setValueAtTime(targetVolume, gainNode.context.currentTime);\n                \n                if (Math.abs(oldGain - targetVolume) > 0.01) {\n                    adjustedCount++;\n                    \n                    // Show visual indicator\n                    const mediaElement = findRelatedMediaElement();\n                    if (mediaElement) {\n                        showVolumeIndicator(mediaElement, targetVolumePercent, adjustmentType);\n                    } else {\n                        showFloatingVolumeIndicator(targetVolumePercent, adjustmentType);\n                    }\n                }\n            }\n        } catch (error) {\n            // Remove invalid gain nodes\n            gainNodes.delete(gainNode);\n        }\n    });\n    \n    if (adjustedCount > 0) {\n        console.log(`Auto Volume: Background script ${adjustmentType === 'boost' ? 'boosted' : 'reduced'} ${adjustedCount} audio source(s) to ${targetVolumePercent}%`);\n    }\n};\n\n// Listen for messages from popup and background script\nchrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n    if (message.type === 'SETTINGS_UPDATED') {\n        settings = message.settings;\n        console.log('Auto Volume: Settings updated', settings);\n        \n        if (!settings.enabled && volumeCheckInterval) {\n            clearInterval(volumeCheckInterval);\n            volumeCheckInterval = null;\n        } else if (settings.enabled && !volumeCheckInterval) {\n            startVolumeMonitoring();\n        }\n        sendResponse({ success: true });\n    } else if (message.type === 'GET_CURRENT_VOLUME') {\n        const volumeInfo = getCurrentVolume();\n        sendResponse(volumeInfo);\n    } else if (message.type === 'ADJUST_VOLUME') {\n        // Handle volume adjustment request from background script\n        const { targetVolume, adjustmentType } = message;\n        adjustAllMediaToTarget(targetVolume, adjustmentType);\n        sendResponse({ success: true });\n    }\n    \n    return true; // Will respond asynchronously\n});\n\n// Initialize the extension\nconst initExtension = async () => {\n    console.log('Auto Volume: Content script loaded');\n    \n    // Set up Web Audio monitoring first (needs to be early)\n    setupWebAudioMonitoring();\n    \n    await loadSettings();\n    findMediaElements();\n    setupMutationObserver();\n    \n    if (settings.enabled) {\n        startVolumeMonitoring();\n    }\n    \n    console.log('Auto Volume: Initialization complete');\n};\n\n// Clean up on page unload\nwindow.addEventListener('beforeunload', () => {\n    if (volumeCheckInterval) {\n        clearInterval(volumeCheckInterval);\n    }\n});\n\n// Start the extension\ninitExtension();"],"names":[],"sourceRoot":""}